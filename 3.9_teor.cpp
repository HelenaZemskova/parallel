// Подключение необходимых библиотек
#include <iostream>      // Для ввода-вывода (std::cout, std::endl)
#include <array>        // Для std::array (статистический массив)
#include <cstdint>      // Для целочисленных типов фиксированного размера (std::uint8_t)
#include <sstream>      // Для работы со строковыми потоками (std::stringstream)
#include <cassert>      // Для макроса assert (проверка условий)

// Класс для представления IPv4 адреса
class IPv4 {
private:
    // Приватное поле: массив из 4 байтов для хранения адреса
    std::array<std::uint8_t, 4> data;  // uint8_t - беззнаковый 8-битный integer (0-255)

public:
    // Конструктор по умолчанию - инициализирует адрес 0.0.0.0
    IPv4() : data{0, 0, 0, 0} {}  // Список инициализации массива нулями
    
    // Конструктор с параметрами - инициализирует адрес a.b.c.d
    IPv4(std::uint8_t a, std::uint8_t b, std::uint8_t c, std::uint8_t d) 
        : data{a, b, c, d} {}  // Список инициализации массива
    
    // Префиксный оператор инкремента (++ip)
    IPv4& operator++() {
        // Проходим по октетам адреса справа налево (от младшего к старшему)
        for (int i = 3; i >= 0; --i) {
            if (data[i] < 255) {  // Если текущий октет не максимальный
                ++data[i];        // Увеличиваем его на 1
                break;            // Прерываем цикл - перенос не нужен
            } else {              // Если текущий октет равен 255
                data[i] = 0;      // Обнуляем его и продолжаем перенос
            }
        }
        return *this;  // Возвращаем ссылку на измененный объект
    }
    
    // Постфиксный оператор инкремента (ip++)
    IPv4 operator++(int) {  // int - фиктивный параметр для区分 префиксной и постфиксной версий
        IPv4 temp = *this;  // Сохраняем текущее состояние
        ++(*this);          // Вызываем префиксный инкремент
        return temp;        // Возвращаем старое состояние
    }
    
    // Префиксный оператор декремента (--ip)
    IPv4& operator--() {
        // Проходим по октетам адреса справа налево
        for (int i = 3; i >= 0; --i) {
            if (data[i] > 0) {    // Если текущий октет не минимальный
                --data[i];        // Уменьшаем его на 1
                break;            // Прерываем цикл - заем не нужен
            } else {              // Если текущий октет равен 0
                data[i] = 255;    // Устанавливаем 255 и продолжаем заем
            }
        }
        return *this;  // Возвращаем ссылку на измененный объект
    }
    
    // Постфиксный оператор декремента (ip--)
    IPv4 operator--(int) {  // int - фиктивный параметр
        IPv4 temp = *this;  // Сохраняем текущее состояние
        --(*this);          // Вызываем префиксный декремент
        return temp;        // Возвращаем старое состояние
    }
    
    // Оператор равенства (дружественная функция)
    friend bool operator==(const IPv4& lhs, const IPv4& rhs) {
        return lhs.data == rhs.data;  // Сравниваем массивы поэлементно
    }
    
    // Оператор неравенства (дружественная функция)
    friend bool operator!=(const IPv4& lhs, const IPv4& rhs) {
        return !(lhs == rhs);  // Используем уже реализованный оператор ==
    }
    
    // Оператор меньше (дружественная функция)
    friend bool operator<(const IPv4& lhs, const IPv4& rhs) {
        return lhs.data < rhs.data;  // Лексикографическое сравнение массивов
    }
    
    // Оператор больше (дружественная функция)
    friend bool operator>(const IPv4& lhs, const IPv4& rhs) {
        return rhs < lhs;  // Используем уже реализованный оператор <
    }
    
    // Оператор меньше или равно (дружественная функция)
    friend bool operator<=(const IPv4& lhs, const IPv4& rhs) {
        return !(rhs < lhs);  // Используем уже реализованный оператор <
    }
    
    // Оператор больше или равно (дружественная функция)
    friend bool operator>=(const IPv4& lhs, const IPv4& rhs) {
        return !(lhs < rhs);  // Используем уже реализованный оператор <
    }
    
    // Оператор вывода в поток (дружественная функция)
    friend std::stringstream& operator<<(std::stringstream& ss, const IPv4& ip) {
        // Выводим каждый октет как число, разделяя точками
        ss << static_cast<int>(ip.data[0]) << '.'  // Приводим uint8_t к int для корректного вывода
           << static_cast<int>(ip.data[1]) << '.' 
           << static_cast<int>(ip.data[2]) << '.' 
           << static_cast<int>(ip.data[3]);
        return ss;  // Возвращаем поток для цепочки операций
    }
    
    // Оператор ввода из потока (дружественная функция)
    friend std::stringstream& operator>>(std::stringstream& ss, IPv4& ip) {
        int a{}, b{}, c{}, d{};    // Временные переменные для октетов
        char dot1{}, dot2{}, dot3{}; // Временные переменные для точек
        
        // Читаем из потока в формате a.b.c.d
        ss >> a >> dot1 >> b >> dot2 >> c >> dot3 >> d;
        
        // Проверяем корректность формата и диапазоны значений
        if (dot1 != '.' || dot2 != '.' || dot3 != '.' ||  // Проверка разделителей
            a < 0 || a > 255 || b < 0 || b > 255 ||       // Проверка диапазонов октетов
            c < 0 || c > 255 || d < 0 || d > 255) {
            ss.setstate(std::ios::failbit);  // Устанавливаем флаг ошибки
            return ss;
        }
        
        // Сохраняем значения в объект IPv4
        ip.data[0] = static_cast<std::uint8_t>(a);  // Приводим int к uint8_t
        ip.data[1] = static_cast<std::uint8_t>(b);
        ip.data[2] = static_cast<std::uint8_t>(c);
        ip.data[3] = static_cast<std::uint8_t>(d);
        
        return ss;  // Возвращаем поток для цепочки операций
    }
};

// Главная функция программы
int main() {
    // Тест 1: Конструкторы
    IPv4 ip1;                    // Конструктор по умолчанию: 0.0.0.0
    IPv4 ip2(192, 168, 1, 1);   // Конструктор с параметрами
    IPv4 ip3(255, 255, 255, 255); // Максимальный адрес
    
    // Тест 2: Вывод в поток
    std::stringstream ss_out;    // Создаем строковый поток для вывода
    ss_out << ip1;               // Выводим ip1 в поток
    assert(ss_out.str() == "0.0.0.0");  // Проверяем результат
    
    ss_out.str("");              // Очищаем поток
    ss_out << ip2;               // Выводим ip2 в поток
    assert(ss_out.str() == "192.168.1.1");  // Проверяем результат
    
    ss_out.str("");              // Очищаем поток
    ss_out << ip3;               // Выводим ip3 в поток
    assert(ss_out.str() == "255.255.255.255");  // Проверяем результат
    std::cout << "Output test passed" << std::endl;  // Сообщение об успехе
    
    // Тест 3: Ввод из потока
    std::stringstream ss_in;     // Создаем строковый поток для ввода
    ss_in.str("192.168.1.1");    // Устанавливаем строку для чтения
    IPv4 ip4;                    // Создаем объект для чтения
    ss_in >> ip4;                // Читаем из потока в ip4
    assert(ip4 == IPv4(192, 168, 1, 1));  // Проверяем результат
    
    ss_in.clear();               // Сбрасываем флаги ошибок
    ss_in.str("10.0.0.1");       // Устанавливаем новую строку
    ss_in >> ip4;                // Читаем из потока в ip4
    assert(ip4 == IPv4(10, 0, 0, 1));  // Проверяем результат
    std::cout << "Input test passed" << std::endl;  // Сообщение об успехе
    
    // Тест 4: Инкремент
    IPv4 ip5(192, 168, 1, 254); // Создаем тестовый адрес
    assert(++ip5 == IPv4(192, 168, 1, 255));  // Префиксный инкремент
    assert(ip5++ == IPv4(192, 168, 1, 255));  // Постфиксный инкремент (возвращает старое значение)
    assert(ip5 == IPv4(192, 168, 2, 0));      // Проверяем новое значение после переноса
    std::cout << "Increment test passed" << std::endl;  // Сообщение об успехе
    
    // Тест 5: Декремент
    IPv4 ip6(192, 168, 2, 1);   // Создаем тестовый адрес
    assert(--ip6 == IPv4(192, 168, 2, 0));   // Префиксный декремент
    assert(ip6-- == IPv4(192, 168, 2, 0));   // Постфиксный декремент (возвращает старое значение)
    assert(ip6 == IPv4(192, 168, 1, 255));   // Проверяем новое значение после заема
    std::cout << "Decrement test passed" << std::endl;  // Сообщение об успехе
    
    // Тест 6: Сравнение
    IPv4 ip7(10, 0, 0, 1);      // Меньший адрес
    IPv4 ip8(10, 0, 0, 2);      // Больший адрес
    assert((ip7 == ip8) == false);  // Проверка неравенства
    assert(ip7 < ip8);           // Проверка оператора <
    assert((ip7 > ip8) == false); // Проверка оператора >
    std::cout << "Comparison test passed" << std::endl;  // Сообщение об успехе
    
    // Тест 7: Граничные случаи
    IPv4 ip9(255, 255, 255, 255); // Максимальный адрес
    ++ip9;                        // Инкремент - должно произойти переполнение
    assert(ip9 == IPv4(0, 0, 0, 0));  // Проверяем сброс до нуля
    
    IPv4 ip10(0, 0, 0, 0);       // Минимальный адрес
    --ip10;                       // Декремент - должно произойти underflow
    assert(ip10 == IPv4(255, 255, 255, 255));  // Проверяем установку максимума
    std::cout << "Edge cases test passed" << std::endl;  // Сообщение об успехе
    
    return 0;  // Успешное завершение программы
}